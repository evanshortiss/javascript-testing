
// Copyright (c) FeedHenry 2011
//
// fhserver - the node.js implementation of FeedHenryServer
//

var nodejsutil = require('util');
var http = require('http');
var https = require('https');
var async = require('async');
var redis = require("redis");
var urbanairship = require('./urbanairship.js');
var helpers = require('./fhhelpers.js');
var report = require('./fh-reports.js');
var fhs = require("fh-statsc");
var url = require('url');
var sync = require('./sync-srv.js');
var sec = require('fh-security');

//IMPORTANT: This will force node to ignore cert errors for https requests
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";


//
// Main FHServer constructor function..
//
function FHServer(cfg, logr) {
  var config = cfg;
  var logger = logr;
  var millicore; var domain; var instance; var widget; var appname; var appapikey;
  var ditch_host; var ditch_port;
  var redisHost; var redisPort; var redisPassword;
  var stats_host; var stats_port; var stats_enabled; var fhStats;
  var APP_API_KEY_HEADER = "X-FH-AUTH-APP";

  // Millicore settings..
  if (cfg && cfg.fhnodeapp) {
    if (cfg.fhnodeapp.millicore) millicore = cfg.fhnodeapp.millicore;
    if (cfg.fhnodeapp.millicore) domain = cfg.fhnodeapp.domain;
    if (cfg.fhnodeapp.instance) instance  = cfg.fhnodeapp.instance;
    if (cfg.fhnodeapp.widget) widget    = cfg.fhnodeapp.widget;
    if (cfg.fhnodeapp.appname) appname    = cfg.fhnodeapp.appname;
    if (cfg.fhnodeapp.appapikey) appapikey = cfg.fhnodeapp.appapikey;
  }

  // Ditch settings
  if (cfg && cfg.fhditch) {
    if (cfg.fhditch.host) ditch_host = cfg.fhditch.host;
    if (cfg.fhditch.port) ditch_port = cfg.fhditch.port;
  }

  // fh-stat settings
  if (cfg && cfg.fhstats) {
    if (cfg.fhstats.host) stats_host = cfg.fhstats.host;
    if (cfg.fhstats.port) stats_port = cfg.fhstats.port;
    if (cfg.fhstats.enabled) stats_enabled = cfg.fhstats.enabled;
  }

  // Redis local settings, overridden below if we're running in CloudFoundry/DynoFarm
  redisPort = 6379;
  redisHost = '127.0.0.1';
  redisPassword = '';

  // DynoFarm overrides
  if (cfg && cfg.redis) {
    if (cfg.redis.host) redisHost = cfg.redis.host;
    if (cfg.redis.port) redisPort = cfg.redis.port;
    if (cfg.redis.password) redisPassword = cfg.redis.password;
  }

  if (process.env.VCAP_SERVICES) {
    var vcapServices = JSON.parse(process.env.VCAP_SERVICES);
    if (vcapServices != undefined && vcapServices != null && (vcapServices['redis-2.2'] != undefined || vcapServices['redis'] != undefined)){
      var cfRedis = (vcapServices['redis-2.2']  || vcapServices['redis'])[0];
      redisHost = cfRedis.credentials.hostname;
      redisPort = cfRedis.credentials.port;
      redisPassword = cfRedis.credentials.password;
      logger.info('Binding to redis: ' + redisHost + ":" + redisPort);
    }else {
      logger.warning("In CloudFoundry environment but no Redis Service specified");
    }
  }

  // redisClient function
  var redisClient = function() {
    var client = redis.createClient(redisPort, redisHost);
    if (process.env.VCAP_SERVICES) {
      client.auth(redisPassword);
    }
    return client;
  };

  function stringify(obj) {
    return JSON.stringify(obj);
  };

  // $fh.parse
  function parse(obj) {
    return JSON.parse(obj);
  };

  function loadWebCache(fhOptions, callback) {
    if (!fhOptions.period) return callback();
    var client = redisClient();
    client.on("connect", function () {
      if (process.env.VCAP_SERVICES) {
        client.auth(redisPassword, function(err, res) {
          if (err) callback(err);
        });
      }
    });
    client.on("error", function (err) {
      return callback(err);
    });
    client.on("ready", function (err) {
      if (err) return callback(err);
      var key = appname + helpers.webCacheKey(fhOptions);
      client.get(key, function(err, reply) {
        client.quit();
        return callback(err, reply);
      });
    });
  };

  function saveWebCache(fhOptions, data, callback) {
    if (!fhOptions.period) return callback();
    var client = redisClient();
    client.on("connect", function () {
      if (process.env.VCAP_SERVICES) {
        client.auth(redisPassword, function(err, res) {
          if (err) callback(err);
        });
      }
    });
    client.on("error", function (err) {
      return callback(err);
    });
    client.on("ready", function (err) {
      if (err) return callback(err);
      var key = appname + helpers.webCacheKey(fhOptions);
      client.setex(key, (fhOptions.period /1000), data, function (err, reply) {
        client.quit();
        return callback(err, {key: key, reply : reply});
      });
    });
  };

  // $fh.web
  function web(fhOptions, callback) {
    if (callback == undefined) {
      throw new Error('callback undefined in $fh.web. See documentation of $fh.web for proper usage');
    }
    // purposely ignore any err from looking in the cache
    loadWebCache(fhOptions, function(err, resp) {
      if (resp){
        //make report
       return callback(undefined, JSON.parse(resp));
      }
      // not cached, so make request
      var nodeOptions = helpers.convertFHOptionsToNodeOptions(fhOptions);
      var fhResp = new Object();
      var protocol = nodeOptions.isSecure ? https : http;

      var req = protocol.request(nodeOptions, function(res) {
        var starttime = new Date().getTime();
        //
        // Note: $fh.web retun object constructed in the following format:
        // http://docs.feedhenry.com/wiki/Web_Requests
        //
        fhResp.status = res.statusCode;
        if (res.headers != undefined && res.headers['content-type'] != undefined) {
          fhResp.contentType = res.headers['content-type'];
        }

        // TODO - transform Cookies into FH cookie array
        // TODO - headers is an object, FH.web expects an array returned
        fhResp.headers = res.headers;
        if(fhOptions.charset != undefined) {
          res.setEncoding(fhOptions.charset);
        }

        var data = '';
        var bytesLength = 0;
        res.on('data', function(chunk) {
          data += chunk;
          bytesLength+=data.length;
        });

        res.on('end', function() {
          fhResp.body = data;
          var endtime = new Date().getTime() - starttime;
          starttime = (starttime / 1000); //create unix timestamp

          //schedule report to be sent on nextTick
          try{
            var repurl = nodeOptions.host.toString() + nodeOptions.path.toString();
            var repdata = {'topic':"fhweb",'url':repurl, 'time':endtime, 'status':res.statusCode, 'start':Number(starttime.toFixed(0)),'bytes':bytesLength};
            report.sendReport(repdata);
          }catch(e){
             // console.log(e.message);
          }
          // save in the cache - note we do this after the callback has been invoked
          // note we also purposely ignore errors here, not much we can do with them..
          process.nextTick(function () {
            saveWebCache(fhOptions, JSON.stringify(fhResp), function(err, resp){
              if(err) console.error(err);
            });
          });
          callback(null, fhResp);
        });
      });
      req.on('error', function(e) {
        var msg = e ? nodejsutil.inspect(e) : 'Undefined error making request';
        msg += " - request: " + nodejsutil.inspect(nodeOptions);
        console.error('Error making request! - ' + msg);
        callback(msg);
      });

      if (fhOptions.body != undefined && fhOptions.method != undefined && fhOptions.method != 'GET') {
        req.write(fhOptions.body);
      }

      req.end();
    });
  };

  //
  // $fhserver.cache() is undocumented publically, but it have the following 'interface':
  // opts.act: can be one of 'save/load/remove'
  // opts.key: the key
  // opts.value: the value
  // opts.expire: the cache expiry value
  //
  // See WidgetMemcacheBean in millicore for more info.
  //
  function cache(opts, callback) {
    if (callback == undefined) {
      throw new Error('callback undefined in $fh.cache. See documentation of $fh.cache for proper usage');
    }

    if (opts.act == undefined){
      return callback('No cache actions defined!');
    }

    var fullKey = appname + opts.key;

    if (opts.act == 'save') {
      var client = redisClient();
      client.on("connect", function () {
        if (process.env.VCAP_SERVICES) {
          client.auth(redisPassword, function(err, res) {
            if (err) callback(err);
          });
        }
      });
      client.on("error", function (err) {
        return callback(err);
      });
      client.on("ready", function (err) {
        if (err) return callback(err);
        if (opts.expire != undefined) {
          client.setex(fullKey, opts.expire, opts.value, function (err, reply) {
            client.quit();
            return callback(err, reply);
          });
        }else {
          client.set(fullKey, opts.value, function (err, reply) {
            client.quit();
            return callback(err, reply);
          });
        }
      });
    }else if (opts.act == 'load') {
      var client = redisClient();
      client.on("connect", function () {
        if (process.env.VCAP_SERVICES) {
          client.auth(redisPassword, function(err, res) {
            if (err) callback(err);
          });
        }
      });
      client.on("error", function (err) {
        callback(err);
        client.end();
      });
      client.on("ready", function (err) {
        if (err) return callback(err);
        client.get(fullKey, function(err, reply) {
          client.quit();
          return callback(err, reply);
        });
      });
    }else if (opts.act == 'remove') {
      var client = redisClient();
      client.on("connect", function () {
        if (process.env.VCAP_SERVICES) {
          client.auth(redisPassword, function(err, res) {
            if (err) callback(err);
          });
        }
      });
      client.on("error", function (err) {
        return callback(err);
      });
      client.on("ready", function (err) {
        if (err) return callback(err);
          client.del(fullKey, function(err, reply) {
          client.quit();
          return callback(err, reply);
        });
      });
    }else {
      return callback("Unknown cache action: " + opts.act);
    }
  };

  //
  // $fh.call() : Call back to millicore from our Node.js code.
  // NOT a public function but may be one day.
  // TODO - this seems to be unsed!
  //      - verify and remove
  //      - also note that it uses hardcoded https here.
  function call(millicore, domain, instId, widgId, path, params, callback) {
    var headers = { "accept" : "application/json" };
    headers["content-type"] = "application/json; charset=utf-8";
    addAppApiKeyHeader(headers);

    var options = {
      host: millicore,
      port: 443,
      path: '/box/srv/1.1/' + path,
      method: 'POST',
      headers: headers
    };

    var addParams = (params == undefined || params == null)? new Object() : helpers.clone(params);
    addParams["instance"] = instId;
    addParams["widget"] =  widgId;

    var fhResp = new Object();
    var req = https.request(options, function (res) {
      fhResp.status = res.statusCode;
      // TODO - *both* of these are recommended ways of setting timeout on http requests..
      // needs further investigation (and proper test case!!)
      req.socket.setTimeout(60000);  // TODO - timeout should be configurable!
      req.connection.setTimeout(60000);
      var data = '';
      res.setEncoding('utf8');
      res.on('data', function(chunk) {
        data += chunk;
      });

      res.on('end', function() {
        fhResp.body = data;
        callback(undefined, fhResp);
      });
    });

    req.on('error', function(e) {
      logger.warning('Problem invoking: ' + e.message);
      callback(e);
    });

    req.write(JSON.stringify(addParams)+"\n");
    req.end();
  };

  //
  // $fh.feed()
  // Same interface as http://docs.feedhenry.com/wiki/Read_Rss_Feed
  //
  function feed(params, callback) {
    if (callback == undefined) {
      throw new Error('callback undefined in $fh.feed. See documentation of $fh.feed for proper usage');
    }

    call(millicore, domain, instance, widget, 'ent/feed/Feed/get_entries', params, callback);
  };

  // $fh.db
  function db(params, callback) {
    if (params.act == undefined) throw new Error("'act' undefined in params. See documentation of $fh.db for proper usage");
    if (params.type == undefined) throw new Error("'type' undefined in params. See documentation of $fh.db for proper usage");
    if (appname == undefined) throw new Error("Internal error - no appId defined");

    params.__fhdb = appname;
    if(process.env.FH_USE_LOCAL_DB) {
      var fhdb = require('fh-db');
      return fhdb.local_db(params, callback);
    } else {
      return net_db(params, callback);
    }
  }

  function net_db(params, callback) {
    var headers = { "accept" : "application/json" };
    headers["content-type"] = "application/json";
    addAppApiKeyHeader(headers);

    var options = {
      host: ditch_host,
      port: ditch_port,
      path: '/data/' + params.act,
      method: 'POST',
      headers: headers
    };
    var protocol = (cfg.fhditch.protocol === "http")? http : https;
    var req = protocol.request(options, function (res) {


      req.socket.setTimeout(60000);  // TODO - timeout should be configurable!
      req.connection.setTimeout(60000);
      var data = '';
      res.on('data', function(chunk) {
        data += chunk;
      });

      res.on('end', function() {
        if (res.statusCode != 200) {
          return callback(new Error(data + " status: " + res.statusCode));
        }
        return callback(undefined, JSON.parse(data));
      });
    });

    req.on('error', function(e) {
      logger.warning('Problem contacting DITCH server: ' + e.message + "\n" + nodejsutil.inspect(e.stack));
      callback(e);
    });

    req.write(JSON.stringify(params)+"\n");
    req.end();

  };

  // $fh.log
  function log(data, showHidden, depth) {
    var hidden = showHidden || false;
    var dep = depth || 2;
    console.log(nodejsutil.inspect(data, hidden, dep));
  };

  // $fh.util
  // If the 'x-feedhenry' header is set, treat as a proxy from Millicore.
  function util(headers, cloudUrl) {
    var fullUri;
    if (headers && headers['x-feedhenry']) {
      fullUri = headers['x-feedhenry'] + '/' + domain + '/' + widget + '/' + cloudUrl + '/' + instance;
    }else {
      fullUri = headers.host + '/' + cloudUrl;
    }
    return fullUri;
  };

  // $fh.push
  function push(opts, callback) {
    if (!opts.act) return callback (new Error("Missing required 'act' parameter: " + JSON.stringify(opts)));
    if (!opts.type) return callback (new Error("Missing required 'type' parameter: " + JSON.stringify(opts)));
    if (!opts.params) return callback (new Error("Missing required 'params' parameter: " + JSON.stringify(opts)));

    var appKeys = helpers.getUAAppKeys(opts.act, opts.type, config);
    var ua = urbanairship.urbanairship(appKeys);

    if ('register' === opts.act) {
      if (!opts.params.id) return callback(new Error("No 'id' parameter specified: " + JSON.stringify(opts.params)));
      if (!opts.params.platform) return callback(new Error("No 'platform' parameter specified: " + JSON.stringify(opts.params)));
      ua.doRegistration(opts.params.platform, opts.params.id, callback);
    } else if ('push' === opts.act) {
      ua.doPush(opts.params, callback);
    } else if ('broadcast' === opts.act) {
      ua.doBroadcast(opts.params, callback);
    } else return callback(new Error("Unknown action: '" + opts.act + "'"));
  };

  function session(){
    var errors                  = {},
    SESSION_PREPEND             = "FHSERVER_SESSION",
    exceptions                  = {};

    errors.INVALID_SESSIONID    = "invalid sessionId it must be a string";
    errors.INVALID_KEY          = "invalid key it must be a string";
    errors.INVALID_DATA         = "data must be a string";
    exceptions.INVALID_CALLBACK = {type:"InvalidCallbackException",message: "cb must be a function"};

    function prependSession(sessionId){
      return SESSION_PREPEND+sessionId;
    }

    function set(sessionId,data,expire,cb){
      if('function' !== typeof cb) throw exceptions.INVALID_CALLBACK;
      if('string' !== typeof sessionId) return cb(errors.INVALID_SESSIONID);
      if('string' !== typeof data) return cb(errors.INVALID_DATA);
      var sessionid = prependSession(sessionId),
      action = {act:'save',key:sessionid,value:data},
      expiry;
      if(expire !== 0){
        expiry = Number(expire);
        if(expiry !== 0) action.expire = expiry;
      }
      cache(action, function (err,suc){
          if(err)return cb(err);
          return cb(undefined,sessionId);
      });
    };

    function get(sessionId,cb){
      if('function' !== typeof cb) throw exceptions.INVALID_CALLBACK;
      if('string' !== typeof sessionId) return cb(errors.INVALID_SESSIONID);
      var internalSid = prependSession(sessionId);
      cache({act:'load',key:internalSid}, function (err,data){
        if(err) return cb(err);
        return cb(undefined,data);
      });
    };

    function remove(sessionId, cb){
      if('function' !== typeof cb) throw exceptions.INVALID_CALLBACK;
      if('string' !== typeof sessionId) return cb(errors.INVALID_SESSIONID);
      var internalSid = prependSession(sessionId);
      cache({act:'remove',key:internalSid}, function (err, suc){
        if(err) return cb(err);
        return cb(undefined,suc);
      });
    };

    //api
    return {
        get : get,
        set : set,
        remove : remove
    };
  };
  //end session

  // $fh.stats()
  function stats() {
    if (!fhStats) {
      fhStats = fhs.FHStats({host: stats_host, port: stats_port, enabled: stats_enabled});
    }

    function formatStatsName(stat, apiStats) {
      var statsType = (apiStats)?"api":"app";
      return appname + '_' + statsType + '_' + stat;
    }

    function inc(stat, apiStats, cb) {
      if ((typeof apiStats === "function") && (!cb)) {
        cb = apiStats;
        apiStats = undefined;
      }

      fhStats.inc(formatStatsName(stat, apiStats), function(err, bytes){
        if(err) logger.error(err);
        if(cb) cb(err);
      });
    }

    function dec(stat, apiStats, cb) {
      if ((typeof apiStats === "function") && (!cb)) {
        cb = apiStats;
        apiStats = undefined;
      }

      fhStats.dec(formatStatsName(stat, apiStats), function(err){
        if(err) logger.error(err);
        if(cb) cb(err);
      });
    }

    function timing(stat, time, apiStats, cb) {
      if ((typeof apiStats === "function") && (!cb)) {
        cb = apiStats;
        apiStats = undefined;
      }

      fhStats.timing(formatStatsName(stat, apiStats), time, function(err){
        if(err) logger.error(err);
        if(cb) cb(err);
      });
    }

    function gauge(stat, value, apiStats, cb) {
      if ((typeof apiStats === "function") && (!cb)) {
        cb = apiStats;
        apiStats = undefined;
      }

      fhStats.gauge(formatStatsName(stat, apiStats), value, function(err){
        if(err) logger.error(err);
        if(cb) cb(err);
      });
    }

    return {
      inc : inc,
      dec : dec,
      timing : timing,
      gauge : gauge
    };
  };

    /**
     * description: fh.act is the server side equivilant of the client side $fh.act.
     * It allows one app to call anothers endpoints which means several apps can share the same
     * state information held by another app
     * @param params {guid:"",endpoint:"",params:{}}
     * @param cb function
     */
  function act() {
      //private set up stuff
      var ERRORS = {
        "InvalidCallback" : "$fh.act requires the final parameter to be a function",
        "InvalidArgument" : "The param %s is invalid it is required to be a %s",
        "MissingArgument" : "The param %s is missing",
        "MissingParms"    : "params is missing",
        "InvalidGuid"     : "The app identifier (guid) is invalid %s . Please check it.",
        "AppNotFound"     : "No app with identifier %s found. Please ensure the identifier is correct"
      };

      function validateParams (params, cb){
        if(! params || 'object' !== typeof params){
            return cb(ERRORS.MissingParms);
        }
        if(! params.hasOwnProperty('guid') || 'string' !== typeof params.guid){
            return cb(nodejsutil.format(ERRORS.InvalidArgument,"guid","string"));
        }
        if(params.guid.length !== 24){
            return cb(nodejsutil.format(ERRORS.InvalidGuid, params.guid));
        }
        if(! params.hasOwnProperty('endpoint') || 'string' !== typeof params.endpoint){
            return cb(nodejsutil.format(ERRORS.InvalidArgument,"endpoint","string"));
        }
        if(params.hasOwnProperty('params') && 'object' !== typeof params['params']){
            return cb(nodejsutil.format(ERRORS.InvalidArgument,"params","object"));
        }
        return cb(null);
      };

      function doAppCall(endpoints, func,params,liveflag,cb) {
        if('object'!== typeof endpoints || endpoints.status !== 200) return cb(nodejsutil.format(ERRORS.AppNotFound,params.guid));
        var retdata = JSON.parse(endpoints['body']);
        var callurl = (liveflag)
          ? retdata['hosts']['live-url']
          : retdata['hosts']['development-url'];
          callurl+="/cloud/"+func;
        var payload = "";
          try{
              payload = JSON.stringify(params);
          }catch(e){
              return cb(" Could not send params " + e.message);
          }
        var urlprops = url.parse(callurl);
        //sometimes there is a port appended to the host url
        var portmatch = urlprops.host.match(/[:\d]*$/);
        var port = (portmatch === null)? 443 : portmatch[0].toString().replace(/:/,"");
        urlprops.host = urlprops.host.replace(/[:\d]*$/,"");
        var headers = {};
        headers["content-type"]   = "application/json";
        headers["content-length"] = new Buffer(payload).length ||0;
        headers["accept"]         = "application/json";
        addAppApiKeyHeader(headers);

        var opts = {
          host:urlprops.host,
          path:urlprops.path,
          port:port,
          method:"POST",
          headers:headers
       };

        var protocol = (urlprops.protocol === "http")? http : https;

       //finally make call to other app
       var req = protocol.request(opts,function (res){
           req.socket.setTimeout(60000);
           req.connection.setTimeout(60000);
           var retData="";
           res.on('data', function (data){
               retData+=data;
           });
           res.on('end',function () {
            return cb(null,retData);
           });
       });
       req.on('error', function (err){
        return cb(err);
       });
       req.write(payload);
       req.end();
     };

      //return our public function
      return function (params, cb) {
          if('function' !== typeof cb) throw {name:"InvalidCallback", message:ERRORS.InvalidCallback};
          validateParams(params, function (err){
              if(err) return cb(err);
              //call millicore hosts endpoint sending the guid of app being called and the guid of the app doing the calling
              call(millicore,domain,instance, widget,"ide/apps/app/hosts",{payload: {"guid": params.guid,calling_guid:widget}}, function (err, data){
                   //construct our call to secondary app
                  if(err) return cb(err);
                  var live = (params.live)?true : false;
                  var funcParams = params.params || {};
                  doAppCall(data,params.endpoint,funcParams,live,cb);
              });
          })
      };
  };

  // Tidyup when the server we're hosted in is closing
  function setServer(server) {
    if(server) {
      server.on('close', function(){
        if (fhStats) fhStats.close();
      });
    }
  };

  function addAppApiKeyHeader(header){
    if(appapikey && appapikey.length > 0){
      header[APP_API_KEY_HEADER] = appapikey;
    }
  }

  function hash(opts, callback){
    var p = {act:'hash', params: opts};
    sec.security(p, callback);
  }



  return {
    stringify: stringify,
    parse: parse,
    web: web,
    cache: cache,
    feed: feed,
    db: db,
    log: log,
    push: push,
    call: call,
    util: util,
    redisPort: redisPort,
    redisHost: redisHost,
    session: session(),
    stats: stats(),
    setServer : setServer,
    sync: sync,
    act : act(),
    sec: sec.security,
    hash: hash
  };
}

exports.FHServer = FHServer;

