var amqp = require('amqp');
var util = require("util");
var async = require("async");
var events = require('events');

function AMQPManager(cfg) {
  var _connection;
  var _disconnectRequested = false;
  var self = this;
  var _exchanges = {};

  // validate config
  if (!cfg.clusterNodes) throw new Error("'clusterNodes' config param missing");
  if (!cfg.maxReconnectAttempts) throw new Error("'maxReconnectAttempts' config param missing");

  // 'clusterNodes' should be an array, but can be a string if passed from commandline
  if (typeof cfg.clusterNodes === 'string') {
    try {
      var tmp = JSON.parse(cfg.clusterNodes);
      cfg.clusterNodes = tmp;
    }catch (x) {
      throw x;
    }
  }

  function setupConn(url, cb) {
    var error;
    _exchanges = {};
    var conn = amqp.createConnection({url: url}, {reconnect: false}, connReadyHandler);

    conn.addListener('error', function(err){
      conn.end(); error = err;
    });

    conn.addListener('close', function(){
      return cb(error);
    });

    function connReadyHandler() {
      // note 'this' is now in the amqp 'connection' context
      _connection = this;
      // wrapped in 'nextTick' for unit test friendliness
      process.nextTick(function(){
        self.emit("connection");
      });
    };
  };

  // create/get handle to exchange
  function exchange(name, callback) {
    var opts = {
      type: 'topic',
      durable: true,
      confirm: true
    };
    if (!_connection) return callback("Fatal: no connection to Message Bus Cluster!");

    // Its possible here that the connection is destroyed i.e another connection being formed.
    // Can't handle this automatically so return an error to the client
    if (_connection.destroyed === true) {
      return callback("Current connection has been destroyed, reconnection in progress...");
    }

    if (_exchanges[name]) return callback(undefined, _exchanges[name]);
    _connection.exchange(name, opts, function(ex){
      _exchanges[name] = ex;
      return callback(undefined, ex);
    });
  };

  // Publish message to a Topic
  this.publishTopic = function(exchangeName, topic, message, callback){
    var self = this;
    exchange(exchangeName, function(err, exchange){
      if(err) return callback(err);

      // TODO - opts can obviously be passed in in future.. important here tho that the deliveryMode is persistent(2)
      var opts = {
        contentType: 'application/json',
        deliveryMode: 2
      };

      exchange.publish(topic, message, opts, function(ack){
        // Note: oddly, ack will be false if the message succeeds
        if (ack !== false) return callback("Error publishing message, ack: " + ack);
        return callback();
      });
    });
  };

  // Subscribe to messages on a topic
  // 'subscribeFunc' is the function that gets called each time a message happens
  this.subscribeToTopic = function(exchangeName, qName, filter, subscribeFunc, opts, callback) {
    if (!callback) {
      callback = opts;
      opts = undefined;
    }
    // If no opts passed, create a durable Q by default.
    if (!opts) {
      opts = {
        autoDelete: false,
        durable: true
      };
    }

    exchange(exchangeName, function(err, exchange){
      if(err) return callback(err);
      _connection.queue(qName, opts, function(q) {
        q.bind(exchange, filter);
        q.subscribe(subscribeFunc);
        callback();
      });
    });
  };

  // cleanly disconnect from the Cluster
  this.disconnect = function(){
    _disconnectRequested = true;
    _connection.end();
  };

  // Connect to our Message Bus Cluster. The algorithm here is quite simple and could be improved, it just
  // cycles through the urls at the moment and gives up after X number of failed attempts.
  this.connectToCluster = function() {
    var count = 0;
    var i = -1;
    async.whilst(
      function () {
        if (_disconnectRequested) return false;
        return count < cfg.maxReconnectAttempts; },
      function (callback) {
        i++;
        if (_disconnectRequested) return callback();
        if(i >= cfg.clusterNodes.length) i = 0;
        setupConn(cfg.clusterNodes[i], function(err) {
          if (err) count++; callback();
        });
      },
      function (err) {
        if (!_disconnectRequested) {
          self.emit("error", "Failed to connect to cluster! Cluster size: " + cfg.clusterNodes.length + " connect attempts: " + cfg.maxReconnectAttempts);
        }else {
          self.emit("disconnected");
        }
      }
    );
  };
};

util.inherits(AMQPManager, events.EventEmitter);
exports.AMQPManager = AMQPManager;